# Two sum
1 bruter force
    vector<int> twoSum(vector<int>& nums, int target) {
       
        for(int i =0;i<nums.size();i++){
            for(int j =i+1;j<nums.size();j++)
            {
                if(nums[i]==target-nums[j])
            return vector<int> {i,j};
            }
        }
 }
2 hashmap
通过数组的下标和数值形成hash map对  快速搜索下标 ，这里付出的代价是o(n)的空间复杂度
   
     vector<int> twosum(vector<int>& nums, int target){
      unordered_map<int, int> sum;
      for(int i =0, i < nums.size();i++){
          if(sum.find(target-nums[i])!=sum.end())
                 return vector<int> {i, sum[target-nums[j]'};
       sum[nums[i]]=i;
       
      }
# Two sum II 有序数组的排列  

1 两个指针的方法 头尾逼近 

头指针和尾指针  对有序数组十分有利

1 有序的查找 
二分查找时间复杂度为o(logn)
n次外部查找 ，总的时间复杂度为o(nlogn)


# Add Two Numbers
考察链表的遍历以及数学运算的分析，dummyhead

# Valid Palindrome 回文字母 string的一些函数 isalnum（） isalpha（）toupper（） tolower（） isspqce()等等 两个指针
# 10 正则匹配式
# 11 最多水的容器(双指针，前后指针 长方形的面积与什么有关） 
# 49存储雨水（每个柱子存储的水 等于左右两边最大值的最小值减去自身的高度）
## 解法一 遍历每一个柱子 获取每一个柱子的存储雨量
```
int trap(vector<int>& height){
int ans=0;
int size=height.size();
for(int i =1,i<size-1;i++){
int left_max=0,right_max=0;
for(int j =i;j>=0;j--){
left_max=max(left_max,height[j])
}
for(j=i;j<size;j++)
{
right_max=max(right_max,height[j])
}
ans+=min(right_max, left_max)-height[i];
}
return ans;
}
```
## 解法2 动态规划的记录数值 占用额外空间的方法 对于上面所说的暴力求解 每次计算i的时候重复计算了i-1之前的值。这些值可以通过开辟额外空间来存储
```
int trap(vector<int>& height){
int ans=0;
int size=height.size();
int leftmax[size],rightmax[size];
leftmax[0]=height[0];
for(int i=1;i<size;i++)
{
leftmax[i]=max(height[i],leftmax[i-1]);
}
rightmax[size-1]=height[size-1];
for(int i=size-2;i>=0;i--)
{
rightmax[i]=max(height[i],rightmax[i+1]);
}
for(int i =1,i<size-1;i++)
{
ans+=min(leftmax[i],rightmax[i])-height[i];
}
return ans;
}
```
## 解法3 使用stac（没看懂）
## 解法4 双指针（没看懂）
